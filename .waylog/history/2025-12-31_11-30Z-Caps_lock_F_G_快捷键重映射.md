# Caps lock F/G 快捷键重映射
_Exported on 12/31/2025 at 19:31:40 GMT+8 from Cursor via WayLog_


**User**

交换 CapsLock + G 和 CapsLock + F:
由 CapsLock + F 全权负责激活 SearchCenter 窗口。
CapsLock + g唤起 “语音输入面板” 或 “旧版快捷面板” 
当 SearchCenter 窗口已激活时，按下 CapsLock + F 执行逻辑根据当前焦点区域分流：
搜索引擎 / 输入框区域：根据输入内容，一键并发跳转（Run）当前选中的搜索引擎组。
ListView 区域：将选中的本地结果（代码片段或 Prompt）直接粘贴（Paste）到 Cursor 窗口。

---


**Cursor**

查找 CapsLock + F 和 CapsLock + G 的实现位置。

---


**User**

CAPSLOCK+F激活窗口的命令覆盖了searchcenter内部的操作命令，要做隔断
capslock+G应该是激活原来的语音搜索面板

---


**Cursor**

修复这两个问题：
1. CapsLock+F 激活窗口的命令覆盖了 SearchCenter 内部的操作，需要做隔断
2. CapsLock+G 应该激活原来的语音搜索面板

检查代码结构：



查找 StartVoiceSearch 函数：

---


**User**

修改capslock+f激活searchcenter以后的操作逻辑：如果 SearchCenter 窗口已激活，如果光标在输入框和搜索引擎区域，CAPSLOCK+f执行搜索操作，如果光标在listview区域，capslock+f执行粘贴到cursor

---


**Cursor**

查看当前实现，然后修改 CapsLock+F 在 SearchCenter 窗口内的操作逻辑：



查看 `ExecuteSearchCenterBatchSearch` 函数的实现：



修改 SearchCenter 窗口内 CapsLock+F 的逻辑：

---


**User**

CapsLock & f:: {
    ShowCursorPanel() ; 这里的 F 还在呼叫老面板
}
CapsLock & g:: {
    ShowCursorPanel() ; 
}
是不是capslock有两套命令代码，存在冲突？

---


**Cursor**

搜索代码中是否存在 `CapsLock & f::` 和 `CapsLock & g::` 的热键定义：

---


**User**

检查这两个问题是否存在：A. CapsLock + F 的角色冲突（第 440-445 行左右）
你在 #HotIf WinActive("ahk_id " . GuiID_SearchCenter) 条件下：
你依然保留了 CapsLock & f 的定义。

当前逻辑：如果窗口已打开，按下 CapsLock + F 会再次调用 ShowSearchCenter()（或者是执行原本的唤起逻辑）。
欠缺：这里没有实现你构想的 “执行操作”（跳转或粘贴）。它目前只是在重复触发窗口的 “显示 / 隐藏” 逻辑，而不是 “开火” 逻辑。

B. WSAD 的全局冲突
在脚本的全局区域（非搜索中心激活状态），你定义了 CapsLock + WSAD 用于光标移动或搜索。
在 SearchCenter 激活状态下，你需要它们执行 “区域跳转”。
风险：由于 ShowSearchCenter 使用了 DetectHiddenWindows，如果判断逻辑不严密，你在 Cursor 里想移动光标时，可能会误触发搜索中心的区域跳转。

---


**Cursor**

检查这两个问题。先查看第440-445行附近的代码：



检查这两个问题。先查看 `IsSearchCenterActive()` 函数的实现，以及是否有其他热键定义：

---


**User**

实现 SQLite 句柄管理的 “终极闭环”：
在全局变量区声明 global global_ST := 0。
修改所有涉及数据库查询的函数（如 PerformSearch, SearchClipboardHistory）：
入口熔断：在执行 DB.Prepare 之前，必须先检查并释放旧句柄：if IsObject(global_ST) { global_ST.Free(), global_ST := 0 }。
过程保底：使用 try...finally 结构，确保无论查询成功还是报错，都在 finally 块中执行 global_ST.Free()。

2. 优化热键优先级与 WSAD 跳转：
确保 #HotIf IsSearchCenterActive() && GetCapsLockState() 的优先级高于全局热键。
在 HandleSearchCenterDown 函数中增加逻辑：当从输入框跳入 ListView 时，自动选中（Focus & Select）列表的第一行，以便用户直接按 F 键 “开火”。

3. 代码清理：
确保 ShowSearchCenter() 函数只负责 UI 的显示和初始化，不包含复杂的业务执行逻辑，实现 UI 与逻辑分离。

---


**Cursor**

查找相关代码，开始实现这三个任务：

---


**User**

请重构脚本中的 SQLite 查询逻辑，确保资源完全释放：

声明全局句柄：在全局变量区明确声明 global global_ST := 0。

重写查询函数：修改 PerformSearch、SearchClipboardHistory 以及所有涉及 DB.Prepare 的函数。

应用 “熔断与保护” 模式：

入口强制释放：在调用 DB.Prepare 之前，必须执行 if IsObject(global_ST) { global_ST.Free(), global_ST := 0 }。

try...finally 闭环：将查询逻辑包裹在 try 块中，并在 finally 块中强制执行 global_ST.Free()。

目的：确保在高频输入搜索时，旧的句柄能被立即物理断开，彻底解决 “数据库被锁定” 的问题。

---


**Cursor**

检查所有使用 `DB.Prepare` 的函数，确保它们都应用了“熔断与保护”模式。



检查并重构所有使用 `DB.Prepare` 的函数，确保它们都应用“熔断与保护”模式：



检查并修复所有函数，确保它们都正确实现了“熔断与保护”模式：



检查并修复所有函数的 finally 块：

---


**User**

继续

---


**Cursor**

继续修复剩余函数，确保所有使用 `DB.Prepare` 的函数都应用“熔断与保护”模式：

---


**User**

继续

---


**Cursor**

检查并修复剩余函数，确保所有使用 `DB.Prepare` 的函数都正确实现“熔断与保护”模式：



检查并修复 `SearchGlobalView` 的 finally 块，确保使用 `global_ST`：

---


**User**

检查 所有的 DB.Prepare 调用，确保它们全部使用了 global_ST 全局变量，并且全部包裹在 try...finally 块中，在 finally 里执行 global_ST.Free()。

---


**Cursor**

检查所有 `DB.Prepare` 调用，确保它们都正确使用 `global_ST` 并包裹在 `try...finally` 中：



检查所有 `DB.Prepare` 调用的 finally 块，确保它们都正确释放 `global_ST`：

---


**User**

添加名为 ActionCountdown 的圆环倒计时模块：

1. 基础参数与全局配置：

时长变量：定义 global LaunchDelaySeconds := 3.0，允许在配置区修改。

状态跟踪：定义 global IsCountdownActive := false。

色彩定义：使用 Cursor 主题蓝（HEX: #007AFF / RGB: 0, 122, 255）。

2. 悬浮窗设计 (CountdownGui)：

属性：必须包含 +AlwaysOnTop +Disabled +NoActivate -Caption +E0x20（E0x20 为点击穿透）。

尺寸与背景：约 80x80 像素的小方块，背景设为完全透明。

定位：

逻辑：自动获取 ahk_exe cursor.exe 的窗口坐标。

位置：将圆环悬浮在 Cursor 窗口右上角内部（Offset: x-100, y + 50）。如果 Cursor 未运行，则显示在屏幕中央。

3. 圆环绘制逻辑 (GDI+ 实现)：

绘制原理：使用 SetTimer 每 30ms 触发一次刷新。

视觉效果：

背景：一个浅灰色的淡透明圆环（底色）。

进度：一个蓝色的圆弧，从 360 度随时间递减至 0 度。

中心：显示倒计时的数字（如 3.0, 2.9...）。

4. 交互流闭环 (核心逻辑)：

触发条件：在 SearchCenter 中按下 F 确认粘贴时：

立即 Hide() 搜索窗口并 global_ST.Free() 释放数据库。

启动 ActionCountdown。

三态分支：

等待 (Default)：计时归零，自动执行 WinActivate("ahk_exe cursor.exe") -> Send("^v")。

加速 (Fast Forward)：倒计时期间，若用户再次按下 F 或 Enter，立即跳过等待直接执行。

取消 (Abort)：按下 Esc，销毁圆环，停止计时，弹出 ToolTip 提示 “已取消”。

5. 健壮性要求：
确保在执行 WinActivate 后有 Sleep(150) 的缓冲，防止粘贴指令发送过快。
每次销毁 GUI 时，务必释放 GDI+ 的 Graphics 资源，防止内存泄露。

---


**Cursor**

实现圆环倒计时模块。先检查相关代码结构：

---


**User**

继续

---


**Cursor**

检查并修复 UpdateLayeredWindow 调用，确保圆环正确显示：

---


**User**

Error: Call to nonexistent function.

Specifically: GdipStartup

	19823: Input := Buffer(A_PtrSize = 8 ? 24 : 16, 0)
	19824: NumPut("UInt", 1, Input, 0)
▶	19825: DllCall("gdiplus.dll\GdipStartup", "Ptr*", &GdiplusToken := 0, "Ptr", Input, "Ptr", 0)
	19826: }

---


**Cursor**

修复 GDI+ 初始化问题：更正 `GdipStartup` 的调用方式。

---


**User**

Error: Invalid option.

Specifically: NoActivate

	19522: }
	19525: InitGDI()
▶	19529: CountdownGui := Gui("+AlwaysOnTop +Disabled +NoActivate -Caption +E0x20", "ActionCountdown")

---
